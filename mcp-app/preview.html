<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="color-scheme" content="dark light">
  <title>Burnout 3-3-3 Wheel</title>
  <style>
    :root {
      --bg: #0d0d0d;
      --bg-gradient: linear-gradient(135deg, #0d0d0d 0%, #1a1a2e 50%, #16213e 100%);
      --text: #ffffff;
      --text-muted: #94a3b8;
      --border: rgba(255,255,255,0.1);
      --card-bg: rgba(255,255,255,0.05);
      --card-border: rgba(255,255,255,0.1);
      --glow-intensity: 0.8;
      
      /* Flame-graph inspired vibrant colors */
      --deep-work-start: #00f260;
      --deep-work-end: #0575e6;
      --deep-work-glow: rgba(0, 242, 96, 0.6);
      
      --quick-wins-start: #f857a6;
      --quick-wins-end: #ff5858;
      --quick-wins-glow: rgba(248, 87, 166, 0.6);
      
      --maintenance-start: #f7971e;
      --maintenance-end: #ffd200;
      --maintenance-glow: rgba(247, 151, 30, 0.6);
      
      --deferred-start: #8e2de2;
      --deferred-end: #4a00e0;
      --deferred-glow: rgba(142, 45, 226, 0.6);
    }
    
    @media (prefers-color-scheme: light) {
      :root {
        --bg: #f8fafc;
        --bg-gradient: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 50%, #cbd5e1 100%);
        --text: #0f172a;
        --text-muted: #64748b;
        --border: rgba(0,0,0,0.1);
        --card-bg: rgba(255,255,255,0.8);
        --card-border: rgba(0,0,0,0.1);
        --glow-intensity: 0.4;
      }
    }
    
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    body {
      font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg-gradient);
      color: var(--text);
      padding: 24px;
      line-height: 1.6;
      min-height: 100vh;
    }
    
    .container {
      max-width: 900px;
      margin: 0 auto;
    }
    
    .header {
      text-align: center;
      margin-bottom: 32px;
    }
    
    .header h1 {
      font-size: 2rem;
      font-weight: 700;
      margin-bottom: 8px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f857a6 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      letter-spacing: -0.02em;
    }
    
    .header .repo {
      color: var(--text-muted);
      font-size: 0.95rem;
      font-weight: 500;
    }
    
    .status {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 14px;
      border-radius: 20px;
      font-size: 0.8rem;
      font-weight: 600;
      margin-top: 12px;
      backdrop-filter: blur(10px);
      border: 1px solid var(--card-border);
    }
    
    .status::before {
      content: '';
      width: 8px;
      height: 8px;
      border-radius: 50%;
      animation: pulse 2s infinite;
    }
    
    .status.connected { 
      background: rgba(0, 242, 96, 0.15); 
      color: #00f260;
      border-color: rgba(0, 242, 96, 0.3);
    }
    .status.connected::before { background: #00f260; box-shadow: 0 0 10px #00f260; }
    
    .status.demo { 
      background: rgba(247, 151, 30, 0.15); 
      color: #f7971e;
      border-color: rgba(247, 151, 30, 0.3);
    }
    .status.demo::before { background: #f7971e; box-shadow: 0 0 10px #f7971e; }
    
    .status.error { 
      background: rgba(255, 88, 88, 0.15); 
      color: #ff5858;
      border-color: rgba(255, 88, 88, 0.3);
    }
    .status.error::before { background: #ff5858; box-shadow: 0 0 10px #ff5858; }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.5; transform: scale(0.8); }
    }
    
    .wheel-section {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 40px;
      position: relative;
    }
    
    .wheel-container {
      position: relative;
      width: 340px;
      height: 340px;
      filter: drop-shadow(0 0 40px rgba(102, 126, 234, 0.3));
    }
    
    #wheel-svg {
      width: 100%;
      height: 100%;
      overflow: visible;
    }
    
    .arc {
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      transform-origin: center;
    }
    
    .arc:hover {
      filter: brightness(1.2) saturate(1.3);
      transform: scale(1.02);
    }
    
    .arc.selected {
      filter: brightness(1.3) saturate(1.4);
      transform: scale(1.04);
    }
    
    .center-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      pointer-events: none;
    }
    
    .center-text .score {
      font-size: 3rem;
      font-weight: 800;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-shadow: 0 0 30px rgba(102, 126, 234, 0.5);
      line-height: 1;
    }
    
    .center-text .label {
      font-size: 0.85rem;
      color: var(--text-muted);
      font-weight: 500;
      margin-top: 4px;
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }
    
    .metrics {
      display: flex;
      gap: 20px;
      justify-content: center;
      margin-bottom: 32px;
      flex-wrap: wrap;
    }
    
    .metric {
      background: var(--card-bg);
      backdrop-filter: blur(20px);
      padding: 20px 28px;
      border-radius: 16px;
      text-align: center;
      min-width: 140px;
      border: 1px solid var(--card-border);
      position: relative;
      overflow: hidden;
      transition: all 0.3s ease;
    }
    
    .metric::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      border-radius: 16px 16px 0 0;
    }
    
    .metric:hover {
      transform: translateY(-4px);
      box-shadow: 0 20px 40px rgba(0,0,0,0.3);
    }
    
    .metric .value {
      font-size: 2rem;
      font-weight: 700;
      line-height: 1.2;
    }
    
    .metric .label {
      font-size: 0.8rem;
      color: var(--text-muted);
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-top: 4px;
    }
    
    .metric.stress::before { background: linear-gradient(90deg, var(--quick-wins-start), var(--quick-wins-end)); }
    .metric.stress .value { 
      background: linear-gradient(135deg, var(--quick-wins-start), var(--quick-wins-end));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .metric.friday::before { background: linear-gradient(90deg, var(--deep-work-start), var(--deep-work-end)); }
    .metric.friday .value { 
      background: linear-gradient(135deg, var(--deep-work-start), var(--deep-work-end));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .legend {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 16px;
      margin-bottom: 32px;
    }
    
    .legend-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 16px 20px;
      background: var(--card-bg);
      backdrop-filter: blur(20px);
      border-radius: 14px;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      border: 1px solid var(--card-border);
      position: relative;
      overflow: hidden;
    }
    
    .legend-item::before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 4px;
      border-radius: 14px 0 0 14px;
      opacity: 0.8;
    }
    
    .legend-item.deep-work::before { background: linear-gradient(180deg, var(--deep-work-start), var(--deep-work-end)); }
    .legend-item.quick-wins::before { background: linear-gradient(180deg, var(--quick-wins-start), var(--quick-wins-end)); }
    .legend-item.maintenance::before { background: linear-gradient(180deg, var(--maintenance-start), var(--maintenance-end)); }
    .legend-item.deferred::before { background: linear-gradient(180deg, var(--deferred-start), var(--deferred-end)); }
    
    .legend-item:hover {
      transform: translateX(8px);
      box-shadow: 0 10px 30px rgba(0,0,0,0.2);
    }
    
    .legend-item.selected {
      transform: translateX(8px) scale(1.02);
      box-shadow: 0 10px 40px rgba(0,0,0,0.3);
    }
    
    .legend-item.selected::before {
      width: 6px;
      opacity: 1;
    }
    
    .legend-dot {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      flex-shrink: 0;
      position: relative;
    }
    
    .legend-dot::after {
      content: '';
      position: absolute;
      inset: -4px;
      border-radius: 50%;
      opacity: 0.3;
      animation: glow-pulse 3s infinite;
    }
    
    .legend-item.deep-work .legend-dot { background: linear-gradient(135deg, var(--deep-work-start), var(--deep-work-end)); box-shadow: 0 0 15px var(--deep-work-glow); }
    .legend-item.quick-wins .legend-dot { background: linear-gradient(135deg, var(--quick-wins-start), var(--quick-wins-end)); box-shadow: 0 0 15px var(--quick-wins-glow); }
    .legend-item.maintenance .legend-dot { background: linear-gradient(135deg, var(--maintenance-start), var(--maintenance-end)); box-shadow: 0 0 15px var(--maintenance-glow); }
    .legend-item.deferred .legend-dot { background: linear-gradient(135deg, var(--deferred-start), var(--deferred-end)); box-shadow: 0 0 15px var(--deferred-glow); }
    
    @keyframes glow-pulse {
      0%, 100% { opacity: 0.3; transform: scale(1); }
      50% { opacity: 0.6; transform: scale(1.1); }
    }
    
    .legend-text {
      flex: 1;
      font-weight: 600;
      font-size: 0.95rem;
    }
    
    .legend-count {
      font-weight: 700;
      font-size: 1.1rem;
      padding: 4px 12px;
      border-radius: 20px;
      background: rgba(255,255,255,0.1);
    }
    
    .bucket-details {
      background: var(--card-bg);
      backdrop-filter: blur(20px);
      border-radius: 16px;
      padding: 24px;
      margin-bottom: 24px;
      display: none;
      border: 1px solid var(--card-border);
      animation: slideUp 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    @keyframes slideUp {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    .bucket-details.visible {
      display: block;
    }
    
    .bucket-details h3 {
      font-size: 1.2rem;
      margin-bottom: 16px;
      display: flex;
      align-items: center;
      gap: 10px;
      font-weight: 700;
    }
    
    .issue-list {
      list-style: none;
    }
    
    .issue-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 14px 16px;
      margin: 8px 0;
      border-radius: 12px;
      cursor: pointer;
      background: rgba(255,255,255,0.03);
      border: 1px solid transparent;
      transition: all 0.2s ease;
    }
    
    .issue-item:hover {
      background: rgba(255,255,255,0.08);
      border-color: var(--card-border);
      transform: translateX(4px);
    }
    
    .issue-number {
      font-family: 'SF Mono', 'Fira Code', monospace;
      color: var(--text-muted);
      font-size: 0.9rem;
      font-weight: 600;
      padding: 4px 10px;
      background: rgba(255,255,255,0.05);
      border-radius: 6px;
    }
    
    .issue-title {
      flex: 1;
      font-weight: 500;
    }
    
    .complexity {
      background: linear-gradient(135deg, rgba(102, 126, 234, 0.2), rgba(118, 75, 162, 0.2));
      padding: 4px 10px;
      border-radius: 8px;
      font-size: 0.8rem;
      font-weight: 600;
      color: #a78bfa;
      border: 1px solid rgba(167, 139, 250, 0.3);
    }
    
    .tooltip {
      position: fixed;
      background: rgba(15, 23, 42, 0.95);
      backdrop-filter: blur(10px);
      color: #fff;
      padding: 10px 16px;
      border-radius: 10px;
      font-size: 0.85rem;
      font-weight: 500;
      pointer-events: none;
      z-index: 1000;
      display: none;
      max-width: 280px;
      box-shadow: 0 20px 40px rgba(0,0,0,0.4);
      border: 1px solid rgba(255,255,255,0.1);
    }
    
    .tooltip.visible {
      display: block;
      animation: fadeIn 0.2s ease;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(4px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    .explanation {
      background: var(--card-bg);
      backdrop-filter: blur(20px);
      border-radius: 16px;
      padding: 24px;
      margin-top: 24px;
      font-size: 0.95rem;
      line-height: 1.7;
      border: 1px solid var(--card-border);
    }
    
    .explanation strong { 
      background: linear-gradient(135deg, var(--deep-work-start), var(--deep-work-end));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      font-weight: 700;
    }
    
    .loading {
      text-align: center;
      padding: 80px 20px;
      color: var(--text-muted);
    }
    
    .loading .spinner {
      width: 56px;
      height: 56px;
      border: 4px solid transparent;
      border-top: 4px solid;
      border-image: linear-gradient(135deg, #667eea, #764ba2, #f857a6) 1;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 20px;
      position: relative;
    }
    
    .loading .spinner::before {
      content: '';
      position: absolute;
      inset: -8px;
      border: 2px solid transparent;
      border-top: 2px solid rgba(102, 126, 234, 0.3);
      border-radius: 50%;
      animation: spin 2s linear infinite reverse;
    }
    
    .loading-text {
      font-size: 1.1rem;
      font-weight: 500;
      background: linear-gradient(135deg, #667eea, #764ba2);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    /* Ambient background animation */
    .ambient-glow {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      overflow: hidden;
      z-index: -1;
    }
    
    .ambient-glow::before,
    .ambient-glow::after {
      content: '';
      position: absolute;
      width: 600px;
      height: 600px;
      border-radius: 50%;
      filter: blur(120px);
      opacity: 0.15;
      animation: float 20s ease-in-out infinite;
    }
    
    .ambient-glow::before {
      background: linear-gradient(135deg, #667eea, #764ba2);
      top: -200px;
      right: -200px;
    }
    
    .ambient-glow::after {
      background: linear-gradient(135deg, #f857a6, #ff5858);
      bottom: -200px;
      left: -200px;
      animation-delay: -10s;
    }
    
    @keyframes float {
      0%, 100% { transform: translate(0, 0) scale(1); }
      33% { transform: translate(30px, -30px) scale(1.1); }
      66% { transform: translate(-20px, 20px) scale(0.9); }
    }
  </style>
</head>
<body>
  <div class="ambient-glow"></div>
  
  <div class="container">
    <div id="loading" class="loading">
      <div class="spinner"></div>
      <div class="loading-text">Analyzing your workload...</div>
    </div>
    
    <div id="content" style="display: none;">
      <div class="header">
        <h1>3-3-3 Day Structure</h1>
        <div class="repo" id="repo-name">-</div>
        <div class="status" id="status">Connecting...</div>
      </div>
      
      <div class="wheel-section">
        <div class="wheel-container">
          <svg id="wheel-svg" viewBox="0 0 340 340"></svg>
          <div class="center-text">
            <div class="score" id="stress-score">-</div>
            <div class="label">Stress Score</div>
          </div>
        </div>
      </div>
      
      <div class="metrics">
        <div class="metric stress">
          <div class="value" id="metric-stress">-</div>
          <div class="label">Stress Level</div>
        </div>
        <div class="metric friday">
          <div class="value" id="metric-friday">-</div>
          <div class="label">Friday Score</div>
        </div>
      </div>
      
      <div class="legend" id="legend"></div>
      
      <div class="bucket-details" id="bucket-details">
        <h3 id="bucket-title">Issues</h3>
        <ul class="issue-list" id="issue-list"></ul>
      </div>
      
      <div class="explanation" id="explanation" style="display: none;"></div>
    </div>
  </div>
  
  <div class="tooltip" id="tooltip"></div>
  
  <script>
    // State
    let wheelData = null;
    let selectedBucket = null;
    let isStandalone = false;
    let pendingRequests = new Map();
    let nextRequestId = 1;
    
    // Vibrant flame-graph inspired bucket configuration
    const BUCKETS = [
      { 
        key: 'deepWork', 
        name: 'Deep Work', 
        cssClass: 'deep-work',
        gradient: { start: '#00f260', end: '#0575e6' },
        glow: 'rgba(0, 242, 96, 0.5)'
      },
      { 
        key: 'quickWins', 
        name: 'Quick Wins', 
        cssClass: 'quick-wins',
        gradient: { start: '#f857a6', end: '#ff5858' },
        glow: 'rgba(248, 87, 166, 0.5)'
      },
      { 
        key: 'maintenance', 
        name: 'Maintenance', 
        cssClass: 'maintenance',
        gradient: { start: '#f7971e', end: '#ffd200' },
        glow: 'rgba(247, 151, 30, 0.5)'
      },
      { 
        key: 'deferred', 
        name: 'Deferred', 
        cssClass: 'deferred',
        gradient: { start: '#8e2de2', end: '#4a00e0' },
        glow: 'rgba(142, 45, 226, 0.5)'
      },
    ];
    
    // MCP Protocol Communication
    function sendRequest(method, params) {
      const id = nextRequestId++;
      return new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
          pendingRequests.delete(id);
          reject(new Error('Request timeout'));
        }, 2000);
        
        pendingRequests.set(id, { resolve, reject, timeout });
        
        // Check if we're in an iframe with a parent that can receive messages
        if (window.parent && window.parent !== window) {
          window.parent.postMessage({ jsonrpc: '2.0', id, method, params: params || {} }, '*');
        } else {
          // No MCP host, reject immediately
          clearTimeout(timeout);
          pendingRequests.delete(id);
          reject(new Error('No MCP host available'));
        }
      });
    }
    
    function sendNotification(method, params) {
      window.parent.postMessage({ jsonrpc: '2.0', method, params: params || {} }, '*');
    }
    
    window.addEventListener('message', (event) => {
      const msg = event.data;
      if (!msg?.jsonrpc) return;
      
      // Handle responses
      if (msg.id !== undefined && pendingRequests.has(msg.id)) {
        const { resolve, reject, timeout } = pendingRequests.get(msg.id);
        clearTimeout(timeout);
        pendingRequests.delete(msg.id);
        msg.error ? reject(new Error(msg.error.message)) : resolve(msg.result);
        return;
      }
      
      // Handle notifications from host
      if (msg.method === 'ui/notifications/tool-input') {
        handleToolInput(msg.params?.arguments || {});
      } else if (msg.method === 'ui/notifications/tool-result') {
        handleToolResult(msg.params);
      } else if (msg.method === 'ui/notifications/host-context-changed') {
        applyHostContext(msg.params);
      }
    });
    
    function handleToolInput(args) {
      // Live preview as model generates
      if (args.dayPlan || args.deepWork || args.quickWins) {
        updateWheel(args);
      }
    }
    
    function handleToolResult(result) {
      if (result?.structuredContent) {
        updateWheel(result.structuredContent);
      }
    }
    
    function applyHostContext(ctx) {
      if (ctx?.theme) {
        document.documentElement.style.colorScheme = ctx.theme;
      }
      if (ctx?.styles?.css?.properties) {
        const root = document.documentElement;
        for (const [key, value] of Object.entries(ctx.styles.css.properties)) {
          root.style.setProperty(key, value);
        }
      }
    }
    
    // Initialize
    async function initialize() {
      try {
        const result = await sendRequest('ui/initialize', {
          protocolVersion: '2026-01-26',
          capabilities: {},
          clientInfo: { name: 'burnout-wheel', version: '1.0.0' }
        });
        
        if (result?.hostContext) {
          applyHostContext(result.hostContext);
        }
        
        sendNotification('ui/notifications/initialized', {});
        updateStatus('connected', 'Connected');
        
      } catch (err) {
        console.log('No MCP host, running standalone:', err.message);
        isStandalone = true;
        updateStatus('demo', 'Demo Mode');
        loadDemoData();
      }
    }
    
    function loadDemoData() {
      updateWheel({
        repo: 'demo/burnout-app',
        dayPlan: {
          deepWork: { number: 42, title: 'Implement caching layer', complexity: 8 },
          quickWins: [
            { number: 18, title: 'Fix typo in README', complexity: 1 },
            { number: 23, title: 'Update dependencies', complexity: 2 },
            { number: 31, title: 'Add unit test', complexity: 2 },
          ],
          maintenance: [
            { number: 15, title: 'Refactor auth module', complexity: 5 },
            { number: 19, title: 'Database migration', complexity: 4 },
            { number: 27, title: 'CI pipeline update', complexity: 3 },
          ],
          deferred: [
            { number: 8, title: 'Major feature X', complexity: 13 },
            { number: 12, title: 'Performance audit', complexity: 8 },
          ],
        },
        stressScore: 35,
        fridayScore: 78,
        agentExplanation: '**Demo Mode** - This is sample data. Connect to an MCP host to see your real workload!',
      });
    }
    
    function updateStatus(type, text) {
      const el = document.getElementById('status');
      el.className = 'status ' + type;
      el.textContent = text;
    }
    
    // Update wheel with data
    function updateWheel(data) {
      wheelData = normalizeData(data);
      
      document.getElementById('loading').style.display = 'none';
      document.getElementById('content').style.display = 'block';
      
      document.getElementById('repo-name').textContent = wheelData.repo || 'Unknown';
      document.getElementById('stress-score').textContent = wheelData.stressScore ?? '-';
      document.getElementById('metric-stress').textContent = getStressEmoji(wheelData.stressScore);
      document.getElementById('metric-friday').textContent = (wheelData.fridayScore ?? '-') + '%';
      
      renderDonut();
      renderLegend();
      
      if (wheelData.agentExplanation) {
        const expEl = document.getElementById('explanation');
        expEl.innerHTML = formatMarkdown(wheelData.agentExplanation);
        expEl.style.display = 'block';
      }
    }
    
    function normalizeData(data) {
      // Handle both flat and nested structures
      const plan = data.dayPlan || data;
      return {
        repo: data.repo || plan.repo,
        deepWork: plan.deepWork,
        quickWins: plan.quickWins || [],
        maintenance: plan.maintenance || [],
        deferred: plan.deferred || [],
        stressScore: data.stressScore ?? plan.stressScore,
        fridayScore: data.fridayScore ?? plan.fridayScore,
        agentExplanation: data.agentExplanation || plan.agentExplanation,
      };
    }
    
    function getStressEmoji(score) {
      if (score === undefined || score === null) return '-';
      if (score < 30) return 'Low';
      if (score < 60) return 'Moderate';
      return 'High';
    }
    
    function formatMarkdown(text) {
      return text
        .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
        .replace(/\n/g, '<br>');
    }
    
    // SVG Donut Chart with Flame-Graph Gradients
    function renderDonut() {
      const svg = document.getElementById('wheel-svg');
      svg.innerHTML = '';
      
      const cx = 170, cy = 170;
      const outerR = 140, innerR = 75;
      
      // Create defs for gradients and filters
      const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
      
      // Add glow filter
      const filter = document.createElementNS('http://www.w3.org/2000/svg', 'filter');
      filter.setAttribute('id', 'glow');
      filter.setAttribute('x', '-50%');
      filter.setAttribute('y', '-50%');
      filter.setAttribute('width', '200%');
      filter.setAttribute('height', '200%');
      filter.innerHTML = `
        <feGaussianBlur stdDeviation="4" result="coloredBlur"/>
        <feMerge>
          <feMergeNode in="coloredBlur"/>
          <feMergeNode in="SourceGraphic"/>
        </feMerge>
      `;
      defs.appendChild(filter);
      
      // Create gradients for each bucket
      BUCKETS.forEach((bucket, i) => {
        const grad = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
        grad.setAttribute('id', 'grad-' + bucket.key);
        grad.setAttribute('gradientTransform', 'rotate(' + (i * 45) + ')');
        grad.innerHTML = `
          <stop offset="0%" stop-color="${bucket.gradient.start}"/>
          <stop offset="100%" stop-color="${bucket.gradient.end}"/>
        `;
        defs.appendChild(grad);
      });
      
      svg.appendChild(defs);
      
      const counts = BUCKETS.map(b => {
        if (b.key === 'deepWork') return wheelData.deepWork ? 1 : 0;
        return (wheelData[b.key] || []).length;
      });
      const total = counts.reduce((a, b) => a + b, 0) || 1;
      
      let startAngle = -Math.PI / 2;
      
      // Add subtle ring behind
      const bgRing = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      bgRing.setAttribute('cx', cx);
      bgRing.setAttribute('cy', cy);
      bgRing.setAttribute('r', (outerR + innerR) / 2);
      bgRing.setAttribute('fill', 'none');
      bgRing.setAttribute('stroke', 'rgba(255,255,255,0.05)');
      bgRing.setAttribute('stroke-width', outerR - innerR);
      svg.appendChild(bgRing);
      
      BUCKETS.forEach((bucket, i) => {
        const count = counts[i];
        if (count === 0) return;
        
        const sliceAngle = (count / total) * 2 * Math.PI;
        const endAngle = startAngle + sliceAngle;
        
        // Create glow shadow path first
        const shadowPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        shadowPath.setAttribute('d', describeArc(cx, cy, innerR - 2, outerR + 2, startAngle + 0.02, endAngle - 0.02));
        shadowPath.setAttribute('fill', bucket.glow);
        shadowPath.setAttribute('filter', 'url(#glow)');
        shadowPath.setAttribute('opacity', '0.6');
        svg.appendChild(shadowPath);
        
        // Main arc with gradient
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', describeArc(cx, cy, innerR, outerR, startAngle + 0.01, endAngle - 0.01));
        path.setAttribute('fill', 'url(#grad-' + bucket.key + ')');
        path.setAttribute('class', 'arc');
        path.setAttribute('data-bucket', bucket.key);
        path.style.filter = 'drop-shadow(0 0 8px ' + bucket.glow + ')';
        
        path.addEventListener('click', () => selectBucket(bucket.key));
        path.addEventListener('mouseenter', (e) => showTooltip(e, bucket, count));
        path.addEventListener('mouseleave', hideTooltip);
        
        svg.appendChild(path);
        startAngle = endAngle;
      });
      
      // Add center decoration ring
      const centerRing = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      centerRing.setAttribute('cx', cx);
      centerRing.setAttribute('cy', cy);
      centerRing.setAttribute('r', innerR - 5);
      centerRing.setAttribute('fill', 'none');
      centerRing.setAttribute('stroke', 'url(#grad-deepWork)');
      centerRing.setAttribute('stroke-width', '2');
      centerRing.setAttribute('opacity', '0.3');
      svg.appendChild(centerRing);
    }
    
    function describeArc(cx, cy, innerR, outerR, startAngle, endAngle) {
      const largeArc = endAngle - startAngle > Math.PI ? 1 : 0;
      
      const x1 = cx + outerR * Math.cos(startAngle);
      const y1 = cy + outerR * Math.sin(startAngle);
      const x2 = cx + outerR * Math.cos(endAngle);
      const y2 = cy + outerR * Math.sin(endAngle);
      const x3 = cx + innerR * Math.cos(endAngle);
      const y3 = cy + innerR * Math.sin(endAngle);
      const x4 = cx + innerR * Math.cos(startAngle);
      const y4 = cy + innerR * Math.sin(startAngle);
      
      return [
        'M', x1, y1,
        'A', outerR, outerR, 0, largeArc, 1, x2, y2,
        'L', x3, y3,
        'A', innerR, innerR, 0, largeArc, 0, x4, y4,
        'Z'
      ].join(' ');
    }
    
    function renderLegend() {
      const container = document.getElementById('legend');
      container.innerHTML = '';
      
      BUCKETS.forEach(bucket => {
        let count;
        if (bucket.key === 'deepWork') {
          count = wheelData.deepWork ? 1 : 0;
        } else {
          count = (wheelData[bucket.key] || []).length;
        }
        
        const item = document.createElement('div');
        item.className = 'legend-item ' + bucket.cssClass + (selectedBucket === bucket.key ? ' selected' : '');
        item.innerHTML = `
          <div class="legend-dot"></div>
          <div class="legend-text">${bucket.name}</div>
          <div class="legend-count">${count}</div>
        `;
        item.addEventListener('click', () => selectBucket(bucket.key));
        container.appendChild(item);
      });
    }
    
    function selectBucket(key) {
      selectedBucket = selectedBucket === key ? null : key;
      
      // Update arc selection
      document.querySelectorAll('.arc').forEach(arc => {
        arc.classList.toggle('selected', arc.dataset.bucket === selectedBucket);
      });
      
      // Update legend selection
      renderLegend();
      
      // Show bucket details
      const details = document.getElementById('bucket-details');
      if (!selectedBucket) {
        details.classList.remove('visible');
        return;
      }
      
      const bucket = BUCKETS.find(b => b.key === selectedBucket);
      document.getElementById('bucket-title').innerHTML = bucket.name;
      
      let issues = [];
      if (selectedBucket === 'deepWork' && wheelData.deepWork) {
        issues = [wheelData.deepWork];
      } else {
        issues = wheelData[selectedBucket] || [];
      }
      
      const list = document.getElementById('issue-list');
      list.innerHTML = issues.map(issue => `
        <li class="issue-item" data-number="${issue.number}">
          <span class="issue-number">#${issue.number}</span>
          <span class="issue-title">${escapeHtml(issue.title)}</span>
          ${issue.complexity ? `<span class="complexity">${issue.complexity}pts</span>` : ''}
        </li>
      `).join('');
      
      // Add click handlers for issues
      list.querySelectorAll('.issue-item').forEach(item => {
        item.addEventListener('click', () => onIssueClick(parseInt(item.dataset.number)));
      });
      
      details.classList.add('visible');
    }
    
    async function onIssueClick(number) {
      const issue = findIssue(number);
      if (!issue) return;
      
      if (isStandalone) {
        const url = `https://github.com/${wheelData.repo}/issues/${number}`;
        window.open(url, '_blank');
        return;
      }
      
      // Send message to chat
      try {
        await sendRequest('ui/message', {
          content: [{
            type: 'text',
            text: `Tell me more about issue #${number}: "${issue.title}"`
          }]
        });
      } catch (err) {
        console.error('Failed to send message:', err);
      }
    }
    
    function findIssue(number) {
      if (wheelData.deepWork?.number === number) return wheelData.deepWork;
      for (const key of ['quickWins', 'maintenance', 'deferred']) {
        const found = (wheelData[key] || []).find(i => i.number === number);
        if (found) return found;
      }
      return null;
    }
    
    function showTooltip(event, bucket, count) {
      const tooltip = document.getElementById('tooltip');
      tooltip.textContent = `${bucket.name}: ${count} item${count !== 1 ? 's' : ''}`;
      tooltip.style.left = event.clientX + 10 + 'px';
      tooltip.style.top = event.clientY + 10 + 'px';
      tooltip.classList.add('visible');
    }
    
    function hideTooltip() {
      document.getElementById('tooltip').classList.remove('visible');
    }
    
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
    
    // Start
    initialize();
  </script>
</body>
</html>